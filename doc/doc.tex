\documentclass[11pt, a4paper]{article}

\usepackage[english,francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[pdftex]{graphicx}
\usepackage{setspace}
\usepackage[french]{varioref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{amsthm}
\usepackage[french, ruled]{algorithm2e}
\geometry{margin=2cm}

\usepackage{tikz}
\usetikzlibrary{calc}   % coordinate calculation
\usepackage{xifthen}

\title{Rassemblement d'agents mobiles}
\author{\'Eloi Perdereau}
%\date{}

\newcommand{\spacee}[1] {
  \begin{tikzpicture}[thick, scale=0.6]
    \def \step {1}
    \def \cc {\step/2}  % center of cell
    \coordinate (offset) at ($(\cc,\cc)$);
    \draw[step=\step] (0,0) grid ($(5,5)$);   % draw the grid, base at #1
    % draw the neighbors
    \foreach \coord in #1 {
      \coordinate[at=\coord, name=A];
      \draw ($(A) + (offset)$) circle ({\cc*0.8});
    }
  \end{tikzpicture}
}

\newcommand{\case}[2] {
  \begin{tikzpicture}[thick, scale=0.6]
    \def \step {1}
    \def \cc {\step/2}  % center of cell
    \coordinate (offset) at ($(\cc,\cc)$);
    \draw[step=\step] (0,0) grid ($(3,3)$);   % draw the grid, base at #1
    % draw the center circle
    \draw ($(1,1) + (offset)$) circle (\cc*0.8);
    % draw the neighbors
    \foreach \coord in #1 {
      \coordinate[at=\coord, name=A];
      \draw ($(A) + (offset)$) circle ({\cc*0.8});
    }
    % draw the movement arrow if #3 is not empty
    \ifthenelse{\equal{#2}{}}{}{
    \draw[->] ($(1,1) + (offset)$) -- ($#2 + (offset)$);
    }
  \end{tikzpicture}
}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{conj}{Conjecture}[section]
\newtheorem{exmp}{Example}[section]

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}

\begin{document}

\maketitle

\section{Cas}

On omet les cas symétriques par rapport au robot du milieu
(rotations de $90^{\circ}$, $180^{\circ}$ et $270^{\circ}$.)

\subsection{0 ou 1 voisins}
\case {{}}                        {}
\case {{(0,0)}}                   {(0,0)}
\case {{(1,0)}}                   {(1,0)}
\case {{(2,0)}}                   {(2,0)}

\subsection{2 voisins}
\case {{(0,0),(1,0)}}             {(1,0)}
\case {{(0,0),(2,0)}}             {(1,0)}
\case {{(2,0),(1,0)}}             {(1,0)}
\case {{(0,0),(2,1)}}             {(1,0)}
\case {{(2,0),(0,1)}}             {(1,0)}
\case {{(0,1),(1,0)}}             {(0,0)}
\case {{(2,1),(1,0)}}             {(2,0)} \\

\case {{(0,2),(2,0)}}             {}
\case {{(0,1),(2,1)}}             {}

\subsection{3 voisins}
\case {{(0,0),(1,0),(2,0)}}       {(1,0)}
\case {{(2,0),(1,0),(2,1)}}       {(1,0)}
\case {{(0,0),(1,0),(2,1)}}       {(1,0)}
\case {{(2,0),(1,0),(0,1)}}       {(1,0)}
\case {{(0,0),(2,1),(2,2)}}       {(1,0)}
\case {{(2,0),(0,1),(0,2)}}       {(1,0)} \\

\case {{(0,0),(2,1),(2,0)}}       {(1,0)}
\case {{(0,0),(0,1),(2,0)}}       {(1,0)} \\

\case {{(0,0),(0,1),(2,1)}}       {}
\case {{(0,2),(2,2),(2,0)}}       {}
\case {{(0,2),(2,2),(1,0)}}       {}
\case {{(1,0),(0,1),(2,1)}}       {}
\case {{(1,2),(0,1),(2,0)}}       {}

\subsection{4 voisins}
\case {{(0,0),(1,0),(2,0),(2,1)}} {(1,0)}
\case {{(0,0),(1,0),(2,0),(0,1)}} {(1,0)} \\

\case {{(0,0),(1,0),(2,0),(2,2)}} {}
\case {{(0,0),(1,0),(2,0),(1,2)}} {}
\case {{(0,2),(1,2),(2,1),(2,0)}} {}
\case {{(0,2),(1,2),(2,1),(1,0)}} {}
\case {{(0,2),(1,2),(2,1),(0,0)}} {}
\case {{(0,0),(1,0),(2,1),(0,1)}} {} \\

\case {{(0,2),(1,2),(2,0),(1,0)}} {}
\case {{(0,2),(1,2),(2,0),(0,0)}} {}
\case {{(0,2),(1,2),(2,0),(0,1)}} {}
\case {{(0,2),(1,2),(1,0),(0,0)}} {}
\case {{(0,2),(2,2),(2,0),(0,0)}} {}
\case {{(1,2),(2,1),(1,0),(0,1)}} {}


\subsection{5 voisins et plus}
Pour énumérer les cas avec 5 et 6 robots voisins, il suffit de prendre le
complémentaire des cas avec respectivement 3 et 2 robots voisins.
Aucun de ces cas n'entraine un mouvement de la part du robot concerné.

\subsection{Extension}

Tel quels, les cas 6 et 13 peuvent conduire à une déconnexion de l'espace. Pour
y remédier, il faut que chaque robot mémorise son entourage d'une ronde sur
l'autre (il ne retient que son entourage précédent.) Puis, si à la ronde
précédente, il était dans le cas 6 ou 13, il faut qu'il vérifie si au moins une
des cases suivante contient un robot : à droite, en bas et en bas à droite. Si
ce n'est pas le cas, il revient à sa position précédente. Les cas symétriques
sont définis de façon analogues. \\

Après avoir réglé ces cas de déconnexions, un autre problème survient avec les
cas 5 et 6. Il se peut que l'espace alterne entre deux états ce qui rend le
rassemblement impossible. Le problème vient du fait que des robots disposés en
quinconce soient de nouveau en quinconce à la ronde suivante (avec des
positions inversés.) Et ainsi, revenir à la position qu'ils occupaient deux
rondes plus tôt.  Pour y remédier, on va de nouveau utiliser l'entourage de
la ronde précédente : Si à la ronde précédente, un robot était dans le cas 5 ou
6, et qu'il est désormais dans le cas opposé, alors il ne bouge pas pour cette
ronde. \\

\subsection{Formalisation}
\begin{algorithm}[H]
  $finish \leftarrow False$\;
  $ok \leftarrow True$\;
  $k \leftarrow 0$\;
  \While{not $finish$} {
    $N_k \leftarrow get\_neighbors()$\;
    \uIf{$k \% 4 = 0$} {
      \If{$N_k$ is case $1.2.\{4,5\}$ or $1.3.\{5,6\}$} {
        move to $(i, j-1)$\;
        $get\_neighbors()$\;
        \If{$(i, j-2)$ or $(i+1, j-2)$ is not empty} {
          $ok \leftarrow False$\;
        }
      }
    }
    \uElseIf{$k \% 4 = 1$} {
      \If{$N_{k-1}$ is case $1.2.4$ or $1.3.5$} {
        move to $(i, j+1)$\;
      }
    }
    \uElseIf{$k \% 4 = 2$} {
      % test d'arrêt
      \uIf{$N_k$ is case $1.1.1$ or \\
          ($N_k$ is case $1.1.\{2,3,4\}$ and $N_{k-2}=rotate180(N_k)$) or \\
          ($N_k$ is case $1.3.2$         and $N_{k-2}=rotate90 (N_k)$) } {
          $finish \leftarrow True$\;
      }
      % mouvement si il n'y a personne en (i,j-2) ou (i+1,j-2)
      \ElseIf{$ok = True$} {
        move according to $N_k$\;
      }
      $ok \leftarrow True$\;
    }
    \Else{
      \If{($N_{k-1}$ is case $1.2.\{4,5\}$ or $1.3.\{5,6\}$) and
          ($(i,j+1)$, $(i-1,j)$, $(i-1,j+1)$ are all empty)} {
          move to $(i-1,j)$\;
      }
    }
    $k \leftarrow k+1$\;
  }
  \caption{}
\end{algorithm}

\subsection{Correctness}

We define the \textit{bounding box} $BB(t)$ of the robots as the smallest
enclosing rectangle (oriented with the grid's axes) which contains all robots
at step $t$.

\begin{lem}
When following the algorithm described above, the bounding box of the robots is
monotonically non-inflating, i.e., $BB(t+1) \subseteq BB(t)$ for all $t$.
\end{lem}

\begin{lem}
If there is exactly one robot in the topmost row of the bounding box, then it
moves down after at most a constant number of steps.
\end{lem}

\section{Calcul du temps de rassemblement dans le cas d'un bloc (draft)}

\subsection{Cas paire}

Bloc de taille $n$ par $n$ avec $n \geq 3$.

On ne considère que un côté (les trois autres sont similaires)

$R$ : le plus petit rectangle englobant tous les robots

\paragraph{Première étape} De bloc à disque

Les deux cases prises par les robots sur les bords du côtés se libèrent à
chaque ronde. Donc à chaque ronde, le nombre de robots sur le côté diminue de
2. Le temps pour qu'il ne reste plus que 4 robots est
\[ \frac{n-4}{2} \]

\paragraph{Deuxième étape} Effondrement du disque (ou du cercle)

Le côté ne contient plus que 4 robots adjacents. Donc au bout de deux
étapes, il s'effondre. On se rend compte que tant que $n \geq 3$,
après chaque effondrement, le côté contient de nouveau 4 robots adjacents. Donc,
pour que l'espace devienne un bloc de taille 2 par 2 (cas terminal), il faut
que chaque côté "descendent" de $n/2-1$, soit un nombre d'étapes de
\[ ( \frac{n}{2} -1 ) *2 \]
Puis il faut une dernière ronde pour que les robots se rendent compte qu'ils
ont terminés.

\paragraph{Totaux} Le temps total $T$ pour que un bloc se rassemble
est donc :

\[ T = ( \frac{n}{2} -1 ) *2 + \frac{n-4}{2} + 1 \]
\[ T = n + \frac{n}{2} - 3 \]


\subsection{Cas impaire}

Le cas impaire est assez similaire :
On utilise des côtés qui ont 3 robots adjacents, et "descendent" en deux
étapes.

\paragraph{Première étape}
\[ \frac{n-3}{2} \]

\paragraph{Deuxième étape}
\[ ( \frac{n-1}{2} ) *2 \]
Pas de ronde en plus après la deuxième étape.

\subsection{Cas général (paire et impaire)}
\[ n + \left\lceil \frac{n}{2} \right\rceil -3 \]
Formule vérifiée pour des blocs de côtés de taille 3 à 50 de côtés de taille 3
à 100.

\subsection{Généralisation aux rectangles}

On considère des rectangles de taille $m$ par $n$ avec $m \leq n$.

\[
    \left\lceil \frac{n-4}{2} \right\rceil
  + 2*\left\lfloor \frac{m}{2} \right\rfloor
  -2\ si\ m\ pair
  +1\ si\ m\ ou\ n\ pair
\]

\subsection{Généralisation aux carrés (blocs vides)}

Tout ce qui a été dis sur les blocs peut s'appliquer (et a été vérifié) aux
carrés et aux rectangles. On peut associer les robots qui forment le contour du
bloc aux robots qui forment le cercle. Puis, on se rend compte que à chaque
étape, les robots correspondant deux à deux prendront la même décision.

\end{document}
